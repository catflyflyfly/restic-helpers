package cli

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/catfly/restic-helpers/internal/config"
	"github.com/spf13/cobra"
)

var useCmd = &cobra.Command{
	Use:   "use <repo-name>",
	Short: "Activate a repository for manual restic commands",
	Long: `Generates an env.sh file that can be sourced to set up environment variables
for running restic commands manually against the specified repository.

Usage:
  restic-helpers use myrepo
  source ~/.config/restic-helpers/repos/myrepo/env.sh
  restic snapshots`,
	Args: cobra.ExactArgs(1),
	RunE: runUse,
}

func init() {
	rootCmd.AddCommand(useCmd)
}

func runUse(cmd *cobra.Command, args []string) error {
	repoName := args[0]

	paths, err := config.GetPaths()
	if err != nil {
		return fmt.Errorf("failed to get paths: %w", err)
	}

	repoDir := filepath.Join(paths.ReposDir, repoName)

	// Check if repository exists
	if _, err := os.Stat(repoDir); os.IsNotExist(err) {
		return fmt.Errorf("repository %q does not exist", repoName)
	}

	nameFile := filepath.Join(repoDir, "name.txt")
	passwordFile := filepath.Join(repoDir, "password.txt")
	envFile := filepath.Join(paths.ConfigDir, "env.sh")

	envContent := fmt.Sprintf(`# This file is auto-generated by 'restic-helpers use' command.
# Source this file to use restic with %s
export RESTIC_REPOSITORY_FILE="%s"
export RESTIC_PASSWORD_FILE="%s"
`, repoName, nameFile, passwordFile)

	if IsDryRun() {
		fmt.Printf("[dry-run] Would write to %s:\n%s", envFile, envContent)
		return nil
	}

	if err := os.WriteFile(envFile, []byte(envContent), 0600); err != nil {
		return fmt.Errorf("failed to write env.sh: %w", err)
	}

	fmt.Printf("Environment file created. To use:\n\n")
	fmt.Printf("  source %s\n", envFile)
	fmt.Printf("  restic snapshots\n")

	return nil
}
