"""CLI commands using Click"""

import plistlib
import subprocess
import sys
from pathlib import Path

import click
from tenacity import retry_if_exception_type

from . import PROG_NAME, CONFIG_DIR, CONFIG_REPO_DIR, DATA_DIR
from .config import Context
from .launchd import generate_launchd_plist
from .notify import send_error_to_telegram, ping_healthcheck, HealthcheckStatus


def format_cmd(cmd):
    """Format command for copy-paste with line continuation"""
    return " \\\n  ".join(cmd)


@click.group()
@click.option("--dry-run", is_flag=True, help="Show commands without executing")
@click.option("--verbose", is_flag=True, help="Explain each step")
@click.pass_context
def cli(ctx: Context, dry_run, verbose):
    ctx.obj = Context(dry_run, verbose)


@cli.command(epilog=f"Example: {PROG_NAME} init my_macbook")
@click.argument("repo_name")
@click.pass_obj
def init(ctx: Context, repo_name):
    """Initialize new repository configuration"""
    repo_dir = CONFIG_REPO_DIR / repo_name

    if ctx.verbose:
        click.echo(f"Initializing repository: {repo_name}")
        click.echo(f"  Target directory: {repo_dir}")

    if repo_dir.exists():
        click.echo(f"Error: Repository '{repo_name}' already exists", err=True)
        sys.exit(1)

    files = ["name.txt", "password.txt", "exclude.txt", "paths.txt", "healthcheck.txt"]

    if ctx.dry_run:
        click.echo(f"mkdir -p {repo_dir}")
        for f in files:
            click.echo(f"touch {repo_dir / f}")
        click.echo(f"chmod 600 {repo_dir / 'password.txt'}")
        click.echo(f"chmod 600 {repo_dir / 'healthcheck.txt'}")
    else:
        if ctx.verbose:
            click.echo("  Creating directory...")
        repo_dir.mkdir(parents=True, exist_ok=True)

        if ctx.verbose:
            click.echo("  Creating config files...")
        for f in files:
            (repo_dir / f).touch()
            if ctx.verbose:
                click.echo(f"    {f}: created")

        if ctx.verbose:
            click.echo("  Securing password file...")
        (repo_dir / "password.txt").chmod(0o600)
        (repo_dir / "healthcheck.txt").chmod(0o600)

        click.echo(f"Created repository configuration: {repo_name}")
        click.echo("Edit the following files:")
        click.echo(f"  {repo_dir}/name.txt           - Repository URL")
        click.echo(f"  {repo_dir}/password.txt       - Repository password")
        click.echo(f"  {repo_dir}/exclude.txt        - Custom exclusions")
        click.echo(f"  {repo_dir}/paths.txt          - Paths to backup")
        click.echo(f"  {repo_dir}/healthcheck.txt    - healthcheck.io URL")


@cli.command()
@click.argument("repo_name")
@click.pass_obj
def use(ctx: Context, repo_name):
    """Set active repo for manual restic commands"""
    repo_dir = CONFIG_REPO_DIR / repo_name

    if not repo_dir.exists():
        click.echo(f"Error: Repository '{repo_name}' not found", err=True)
        sys.exit(1)

    env_file = CONFIG_DIR / "env.sh"

    content = f'''# Generated by restic-helpers
# Source this in your shell config
export RESTIC_REPOSITORY_FILE="{repo_dir / "name.txt"}"
export RESTIC_PASSWORD_FILE="{repo_dir / "password.txt"}"
'''

    if ctx.dry_run:
        click.echo(f"# Would write to {env_file}:")
        click.echo("# -------")
        click.echo(content)
        click.echo("# -------")
        click.echo(f"chmod 600 {env_file}")
        return

    env_file.write_text(content)
    env_file.chmod(0o600)
    click.echo(f"Active repo: {repo_name}")
    click.echo(f"Source in shell: source {env_file}")


@cli.command(epilog=f"Example: {PROG_NAME} --verbose backup my_macbook")
@click.argument("repo_name")
@click.pass_obj
def backup(ctx: Context, repo_name):
    """Run backup and prune old snapshots"""
    if ctx.verbose:
        click.echo(f"Starting backup for repository: {repo_name}")

    # Load repository configuration
    repo_dir = CONFIG_REPO_DIR / repo_name

    if not repo_dir.exists():
        click.echo(f"Error: Repository '{repo_name}' not found", err=True)
        click.echo(f"Run: restic-helpers init {repo_name}", err=True)
        sys.exit(1)

    if ctx.verbose:
        click.echo(f"  Repository directory: {repo_dir}")

    # Check required files exist
    repo_file = repo_dir / "name.txt"
    password_file = repo_dir / "password.txt"
    paths_file = repo_dir / "paths.txt"
    exclude_file = repo_dir / "exclude.txt"
    core_exclude_file = DATA_DIR / "core.exclude.txt"

    if ctx.verbose:
        click.echo("  Checking required files...")

    for f in [repo_file, password_file, paths_file]:
        if not f.exists():
            click.echo(f"Error: Required file missing: {f}", err=True)
            sys.exit(1)
        if ctx.verbose:
            click.echo(f"    {f}: ok")

    # Build backup command
    backup_cmd = [
        "restic",
        "backup",
        f"--repository-file={repo_file}",
        f"--password-file={password_file}",
        f"--files-from={paths_file}",
        f"--exclude-file={core_exclude_file}",
        f"--exclude-file={exclude_file}",
        "--exclude-caches",
    ]

    # Get prune config (repo-specific or global)
    prune = ctx.config.repos.get(repo_name, ctx.config).prune

    # Build prune command
    prune_cmd = [
        "restic",
        "forget",
        f"--repository-file={repo_file}",
        f"--password-file={password_file}",
        "--keep-daily",
        str(prune.keep_daily),
        "--keep-weekly",
        str(prune.keep_weekly),
        "--keep-monthly",
        str(prune.keep_monthly),
        "--prune",
    ]
    if ctx.verbose:
        backup_cmd.append("--verbose")
        prune_cmd.append("--verbose")

    # Run backup
    if ctx.dry_run:
        click.echo("# Backup command:")
        click.echo(format_cmd(backup_cmd))
        click.echo()
        ping_healthcheck(ctx, repo_name, HealthcheckStatus.START)
        click.echo("# On success:")
        ping_healthcheck(ctx, repo_name, HealthcheckStatus.SUCCESS)
        click.echo("# On error:")
        ping_healthcheck(ctx, repo_name, HealthcheckStatus.FAIL)
        send_error_to_telegram(ctx, "backup", repo_name, "<stderr>")
        click.echo()
    else:
        if ctx.verbose:
            click.echo("  Running backup...")

        error_file = Path("/tmp/restic-backup-error.txt")

        try:
            ping_healthcheck(ctx, repo_name, HealthcheckStatus.START)
            result = ctx.config.retry.retryer(
                retry_on=retry_if_exception_type(subprocess.CalledProcessError),
                verbose=ctx.verbose,
            )(
                subprocess.run,
                backup_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True,
            )
            click.echo(result.stdout)
            if ctx.verbose:
                click.echo("  Backup completed, sending success notification...")
            ping_healthcheck(ctx, repo_name, HealthcheckStatus.SUCCESS)

        except subprocess.CalledProcessError as e:
            error_file.write_text(e.stderr)
            click.echo(e.stderr, err=True)
            if ctx.verbose:
                click.echo("  Backup failed, sending error notification...")
            ping_healthcheck(ctx, repo_name, HealthcheckStatus.FAIL)
            send_error_to_telegram(ctx, "backup", repo_name, e.stderr)
            sys.exit(e.returncode)

    # Prune old snapshots
    if ctx.dry_run:
        click.echo("# Prune command:")
        click.echo(format_cmd(prune_cmd))
    else:
        if ctx.verbose:
            click.echo("  Pruning old snapshots...")
        ctx.config.retry.retryer(
            retry_on=retry_if_exception_type(subprocess.CalledProcessError),
            verbose=ctx.verbose,
        )(subprocess.run, prune_cmd, check=True)
        if ctx.verbose:
            click.echo("  Prune completed")


@cli.command(epilog=f"Example: {PROG_NAME} check my_macbook")
@click.argument("repo_name")
@click.pass_obj
def check(ctx: Context, repo_name):
    """Verify repository integrity"""
    dry_run = ctx.dry_run
    verbose = ctx.verbose

    if verbose:
        click.echo(f"Checking repository: {repo_name}")

    repo_dir = CONFIG_REPO_DIR / repo_name

    if not repo_dir.exists():
        click.echo(f"Error: Repository '{repo_name}' not found", err=True)
        sys.exit(1)

    repo_file = repo_dir / "name.txt"
    password_file = repo_dir / "password.txt"

    for f in [repo_file, password_file]:
        if not f.exists():
            click.echo(f"Error: Required file missing: {f}", err=True)
            sys.exit(1)
        if verbose:
            click.echo(f"  {f}: ok")

    cmd = [
        "restic",
        "check",
        f"--repository-file={repo_file}",
        f"--password-file={password_file}",
    ]

    if ctx.verbose:
        cmd.append("--verbose")

    if dry_run:
        click.echo("# Check command:")
        click.echo(format_cmd(cmd))
        click.echo()
        click.echo("# On success:")
        click.echo("# On error:")
        send_error_to_telegram(ctx, "check", repo_name, "<stderr>")
    else:
        if verbose:
            click.echo("  Running check...")

        try:
            result = ctx.config.retry.retryer(
                retry_on=retry_if_exception_type(subprocess.CalledProcessError),
                verbose=ctx.verbose,
            )(
                subprocess.run,
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True,
            )
            click.echo(result.stdout)
            if verbose:
                click.echo("  Check passed, sending notification...")

        except subprocess.CalledProcessError as e:
            click.echo(e.stderr, err=True)
            if verbose:
                click.echo("  Check failed, sending notification...")
            send_error_to_telegram(ctx, "check", repo_name, e.stderr)
            sys.exit(e.returncode)


@cli.command(epilog=f'Example: {PROG_NAME} schedule my_macbook "30 14 * * *"')
@click.argument("repo_name")
@click.argument("cron_expr")
@click.pass_obj
def schedule(ctx: Context, repo_name, cron_expr):
    """Schedule automated backup using launchd (macOS only)"""
    if sys.platform != "darwin":
        click.echo("Error: Scheduling only supported on macOS", err=True)
        sys.exit(1)

    repo_dir = CONFIG_REPO_DIR / repo_name
    if not repo_dir.exists():
        click.echo(f"Error: Repository '{repo_name}' not found", err=True)
        click.echo(f"Run: restic-helpers init {repo_name}", err=True)
        sys.exit(1)

    if ctx.verbose:
        click.echo(f"Scheduling backup for repository: {repo_name}")
        click.echo(f"  Cron expression: {cron_expr}")

    label = f"local.restic.backup.{repo_name}"
    plist_file = Path.home() / "Library/LaunchAgents" / f"{label}.plist"
    log_dir = Path.home() / ".local/state/restic-helpers" / repo_name

    if ctx.verbose:
        click.echo(f"  Label: {label}")
        click.echo(f"  Plist: {plist_file}")
        click.echo(f"  Log dir: {log_dir}")

    plist_data = generate_launchd_plist(repo_name, cron_expr)

    load_cmd = ["launchctl", "load", str(plist_file)]

    if ctx.dry_run:
        click.echo("# Plist content:")
        click.echo(plistlib.dumps(plist_data).decode())
        click.echo()
        click.echo("# Commands:")
        click.echo(f"mkdir -p {plist_file.parent}")
        click.echo(f"mkdir -p {log_dir}")
        click.echo(f"# write plist to {plist_file}")
        click.echo(format_cmd(load_cmd))
    else:
        if ctx.verbose:
            click.echo("  Creating directories...")
        plist_file.parent.mkdir(parents=True, exist_ok=True)
        log_dir.mkdir(parents=True, exist_ok=True)

        if ctx.verbose:
            click.echo("  Writing plist...")
        with open(plist_file, "wb") as f:
            plistlib.dump(plist_data, f)

        if ctx.verbose:
            click.echo("  Loading into launchd...")
        subprocess.run(load_cmd, check=True)

        click.echo(f"Scheduled: {label}")


@cli.command(epilog=f"Example: {PROG_NAME} unschedule my_macbook")
@click.argument("repo_name")
@click.pass_obj
def unschedule(ctx: Context, repo_name):
    """Remove scheduled backup (macOS only)"""
    if sys.platform != "darwin":
        click.echo("Error: Scheduling only supported on macOS", err=True)
        sys.exit(1)

    label = f"local.restic.backup.{repo_name}"
    plist_file = Path.home() / "Library/LaunchAgents" / f"{label}.plist"

    if ctx.verbose:
        click.echo(f"Unscheduling backup for repository: {repo_name}")
        click.echo(f"  Label: {label}")
        click.echo(f"  Plist: {plist_file}")

    if not plist_file.exists():
        click.echo(f"Error: Schedule not found for {repo_name}", err=True)
        sys.exit(1)

    unload_cmd = ["launchctl", "unload", str(plist_file)]

    if ctx.dry_run:
        click.echo("# Commands:")
        click.echo(format_cmd(unload_cmd))
        click.echo(f"rm {plist_file}")
    else:
        if ctx.verbose:
            click.echo("  Unloading from launchd...")
        subprocess.run(unload_cmd, check=True)

        if ctx.verbose:
            click.echo("  Removing plist...")
        plist_file.unlink()

        click.echo(f"Unscheduled: {label}")


def main():
    cli(prog_name=PROG_NAME)


if __name__ == "__main__":
    main()
